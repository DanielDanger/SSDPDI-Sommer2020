"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const events_1 = require("events");
const fp_ts_1 = require("fp-ts");
const pipeable_1 = require("fp-ts/lib/pipeable");
const path = __importStar(require("path"));
const promise_retry_1 = __importDefault(require("promise-retry"));
const segfault_handler_1 = __importDefault(require("segfault-handler"));
const typed_duration_1 = require("typed-duration");
const uuid_1 = require("uuid");
const lib_1 = require("../lib");
const ConfigurationHydrator_1 = require("../lib/ConfigurationHydrator");
const ConnectionFactory_1 = require("../lib/ConnectionFactory");
const impure_1 = require("../lib/deployWorkflow/impure");
const pure_1 = require("../lib/deployWorkflow/pure");
const OAuthProvider_1 = require("../lib/OAuthProvider");
const SimpleLogger_1 = require("../lib/SimpleLogger");
const utils_1 = require("../lib/utils");
const ZBJsonLogger_1 = require("../lib/ZBJsonLogger");
const ZBWorkerSignature_1 = require("../lib/ZBWorkerSignature");
const ZBBatchWorker_1 = require("./ZBBatchWorker");
const ZBWorker_1 = require("./ZBWorker");
segfault_handler_1.default.registerHandler(`crash-${uuid_1.v4()}.log`); // With no argument, SegfaultHandler will generate a generic log file name
const idColors = [
    chalk_1.default.yellow,
    chalk_1.default.green,
    chalk_1.default.cyan,
    chalk_1.default.magenta,
    chalk_1.default.blue,
];
exports.ConnectionStatusEvent = {
    ConnectionError: 'connectionError',
    Ready: 'ready',
    Unknown: 'unknown',
};
class ZBClient extends events_1.EventEmitter {
    constructor(gatewayAddress, options) {
        super();
        this.connectionTolerance = process.env
            .ZEEBE_CONNECTION_TOLERANCE
            ? parseInt(process.env.ZEEBE_CONNECTION_TOLERANCE, 10)
            : ZBClient.DEFAULT_CONNECTION_TOLERANCE;
        this.connected = undefined;
        this.readied = false;
        this.closing = false;
        this.workerCount = 0;
        this.workers = [];
        if (typeof gatewayAddress === 'object') {
            options = gatewayAddress;
            gatewayAddress = undefined;
        }
        const opts = options ? options : {};
        this.options = {
            longPoll: ZBClient.DEFAULT_LONGPOLL_PERIOD,
            ...opts,
            retry: opts.retry !== false,
        };
        this.options.loglevel =
            process.env.ZEEBE_NODE_LOG_LEVEL ||
                this.options.loglevel ||
                'INFO';
        this.loglevel = this.options.loglevel;
        const logTypeFromEnvironment = () => ({
            JSON: ZBJsonLogger_1.ZBJsonLogger,
            SIMPLE: SimpleLogger_1.ZBSimpleLogger,
        }[process.env.ZEEBE_NODE_LOG_TYPE || 'NONE']);
        this.options.stdout =
            this.options.stdout || logTypeFromEnvironment() || SimpleLogger_1.ZBSimpleLogger;
        this.stdout = this.options.stdout;
        this.options = ConfigurationHydrator_1.ConfigurationHydrator.configure(gatewayAddress, this.options);
        this.gatewayAddress = `${this.options.hostname}:${this.options.port}`;
        this.oAuth = this.options.oAuth
            ? new OAuthProvider_1.OAuthProvider(this.options.oAuth)
            : undefined;
        this.useTLS =
            this.options.useTLS === true ||
                (!!this.options.oAuth && this.options.useTLS !== false);
        this.basicAuth = this.options.basicAuth;
        this.connectionTolerance = typed_duration_1.Duration.milliseconds.from(this.options.connectionTolerance || this.connectionTolerance);
        this.onConnectionError = this.options.onConnectionError;
        this.onReady = this.options.onReady;
        const { grpcClient, log } = this.constructGrpcClient({
            grpcConfig: {
                namespace: this.options.logNamespace || 'ZBClient',
            },
            logConfig: {
                _tag: 'ZBCLIENT',
                loglevel: this.loglevel,
                namespace: this.options.logNamespace || 'ZBClient',
                pollInterval: this.options.longPoll
                    ? typed_duration_1.Duration.milliseconds.from(this.options.longPoll)
                    : undefined,
                stdout: this.stdout,
            },
        });
        grpcClient.on(exports.ConnectionStatusEvent.ConnectionError, () => {
            var _a;
            if (this.connected !== false) {
                (_a = this.onConnectionError) === null || _a === void 0 ? void 0 : _a.call(this);
                this.emit(exports.ConnectionStatusEvent.ConnectionError);
            }
            this.connected = false;
            this.readied = false;
        });
        grpcClient.on(exports.ConnectionStatusEvent.Ready, () => {
            var _a;
            if (!this.readied) {
                (_a = this.onReady) === null || _a === void 0 ? void 0 : _a.call(this);
                this.emit(exports.ConnectionStatusEvent.Ready);
            }
            this.connected = true;
            this.readied = true;
        });
        this.grpc = grpcClient;
        this.logger = log;
        this.retry = this.options.retry !== false;
        this.maxRetries =
            this.options.maxRetries || ZBClient.DEFAULT_MAX_RETRIES;
        this.maxRetryTimeout =
            this.options.maxRetryTimeout || ZBClient.DEFAULT_MAX_RETRY_TIMEOUT;
        // Send command to broker to eagerly fail / prove connection.
        // This is useful for, for example: the Node-Red client, which wants to
        // display the connection status.
        if (!!this.options.eagerConnection) {
            this.topology()
                .then(res => {
                this.logger.logDirect(chalk_1.default.blueBright('Zeebe cluster topology:'));
                this.logger.logDirect(res.brokers);
            })
                .catch(e => {
                // Swallow exception to avoid throwing if retries are off
                if (e.thisWillNeverHappenYo) {
                    this.emit('never');
                }
            });
        }
    }
    activateJobs(request) {
        return new Promise(async (resolve, reject) => {
            try {
                const stream = await this.grpc.activateJobsStream(request);
                stream.on('data', (res) => {
                    const jobs = res.jobs.map(job => lib_1.parseVariablesAndCustomHeadersToJSON(job));
                    resolve(jobs);
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    async cancelWorkflowInstance(workflowInstanceKey) {
        utils_1.Utils.validateNumber(workflowInstanceKey, 'workflowInstanceKey');
        return this.executeOperation('cancelWorkflowInstance', () => this.grpc.cancelWorkflowInstanceSync({
            workflowInstanceKey,
        }));
    }
    createBatchWorker(conf) {
        var _a;
        if (this.closing) {
            throw new Error('Client is closing. No worker creation allowed!');
        }
        const config = ZBWorkerSignature_1.decodeCreateZBWorkerSig({
            idOrTaskTypeOrConfig: conf,
        });
        // Merge parent client options with worker override
        const options = {
            ...this.options,
            loglevel: this.loglevel,
            onConnectionError: undefined,
            onReady: undefined,
            ...config.options,
        };
        const idColor = idColors[this.workerCount++ % idColors.length];
        // Give worker its own gRPC connection
        const { grpcClient: workerGRPCClient, log } = this.constructGrpcClient({
            grpcConfig: {
                namespace: 'ZBWorker',
                tasktype: config.taskType,
            },
            logConfig: {
                _tag: 'ZBWORKER',
                colorise: true,
                id: (_a = config.id) !== null && _a !== void 0 ? _a : uuid_1.v4(),
                loglevel: options.loglevel,
                namespace: ['ZBWorker', options.logNamespace].join(' ').trim(),
                pollInterval: options.longPoll || ZBClient.DEFAULT_LONGPOLL_PERIOD,
                stdout: options.stdout,
                taskType: `${config.taskType} (batch)`,
            },
        });
        const worker = new ZBBatchWorker_1.ZBBatchWorker({
            grpcClient: workerGRPCClient,
            id: config.id || null,
            idColor,
            log,
            options: { ...this.options, ...options },
            taskHandler: config.taskHandler,
            taskType: config.taskType,
            zbClient: this,
        });
        this.workers.push(worker);
        return worker;
    }
    createWorker(idOrTaskTypeOrConfig, taskTypeOrTaskHandler, taskHandlerOrOptions, optionsOrOnConnectionError, onConnectionError) {
        if (this.closing) {
            throw new Error('Client is closing. No worker creation allowed!');
        }
        const idColor = idColors[this.workerCount++ % idColors.length];
        const config = ZBWorkerSignature_1.decodeCreateZBWorkerSig({
            idOrTaskTypeOrConfig,
            onConnectionError,
            optionsOrOnConnectionError,
            taskHandlerOrOptions,
            taskTypeOrTaskHandler,
        });
        // Merge parent client options with worker override
        const options = {
            ...this.options,
            loglevel: this.loglevel,
            onConnectionError: undefined,
            onReady: undefined,
            ...config.options,
        };
        // Give worker its own gRPC connection
        const { grpcClient: workerGRPCClient, log } = this.constructGrpcClient({
            grpcConfig: {
                namespace: 'ZBWorker',
                tasktype: config.taskType,
            },
            logConfig: {
                _tag: 'ZBWORKER',
                colorise: true,
                id: config.id,
                loglevel: options.loglevel,
                namespace: ['ZBWorker', options.logNamespace].join(' ').trim(),
                pollInterval: options.longPoll || ZBClient.DEFAULT_LONGPOLL_PERIOD,
                stdout: options.stdout,
                taskType: config.taskType,
            },
        });
        const worker = new ZBWorker_1.ZBWorker({
            grpcClient: workerGRPCClient,
            id: config.id || null,
            idColor,
            log,
            options: { ...this.options, ...options },
            taskHandler: config.taskHandler,
            taskType: config.taskType,
            zbClient: this,
        });
        this.workers.push(worker);
        return worker;
    }
    /**
     * Gracefully shut down all workers, draining existing tasks, and return when it is safe to exit.
     * @returns Promise
     * @memberof ZBClient
     */
    async close(timeout) {
        this.closePromise =
            this.closePromise ||
                new Promise(async (resolve) => {
                    // Prevent the creation of more workers
                    this.closing = true;
                    await Promise.all(this.workers.map(w => w.close(timeout)));
                    await this.grpc.close(timeout); // close the client GRPC channel
                    this.emit('close');
                    this.grpc.removeAllListeners();
                    this.removeAllListeners();
                    // console.log((process as any)._getActiveHandles())
                    resolve();
                });
        return this.closePromise;
    }
    completeJob(completeJobRequest) {
        const withStringifiedVariables = lib_1.stringifyVariables(completeJobRequest);
        this.logger.logDebug(withStringifiedVariables);
        return this.executeOperation('completeJob', () => this.grpc.completeJobSync(withStringifiedVariables));
    }
    createWorkflowInstance(configOrbpmnProcessId, variables) {
        const isConfigObject = (conf) => typeof conf === 'object';
        const request = isConfigObject(configOrbpmnProcessId)
            ? {
                bpmnProcessId: configOrbpmnProcessId.bpmnProcessId,
                variables: configOrbpmnProcessId.variables,
                version: configOrbpmnProcessId.version || -1,
            }
            : {
                bpmnProcessId: configOrbpmnProcessId,
                variables,
                version: -1,
            };
        const createWorkflowInstanceRequest = {
            bpmnProcessId: request.bpmnProcessId,
            variables: request.variables,
            version: request.version,
        };
        return this.executeOperation('createWorkflowInstance', () => this.grpc.createWorkflowInstanceSync(lib_1.stringifyVariables(createWorkflowInstanceRequest)));
    }
    createWorkflowInstanceWithResult(configOrBpmnProcessId, variables) {
        const isConfigObject = (config) => typeof config === 'object';
        const request = isConfigObject(configOrBpmnProcessId)
            ? {
                bpmnProcessId: configOrBpmnProcessId.bpmnProcessId,
                fetchVariables: configOrBpmnProcessId.fetchVariables,
                requestTimeout: configOrBpmnProcessId.requestTimeout || 0,
                variables: configOrBpmnProcessId.variables,
                version: configOrBpmnProcessId.version || -1,
            }
            : {
                bpmnProcessId: configOrBpmnProcessId,
                fetchVariables: undefined,
                requestTimeout: 0,
                variables,
                version: -1,
            };
        const createWorkflowInstanceRequest = lib_1.stringifyVariables({
            bpmnProcessId: request.bpmnProcessId,
            variables: request.variables,
            version: request.version,
        });
        return this.executeOperation('createWorkflowInstanceWithResult', () => this.grpc.createWorkflowInstanceWithResultSync({
            fetchVariables: request.fetchVariables,
            request: createWorkflowInstanceRequest,
            requestTimeout: request.requestTimeout,
        })).then(res => lib_1.parseVariables(res));
    }
    /**
     *
     * @param workflow - A path or array of paths to .bpmn files or an object describing the workflow
     */
    async deployWorkflow(workflow) {
        const deploy = (workflows) => this.executeOperation('deployWorkflow', () => this.grpc.deployWorkflowSync({
            workflows,
        }));
        const error = (e) => Promise.reject(`Deployment failed. The following files were not found: ${e.join(', ')}.`);
        return pipeable_1.pipe(pure_1.bufferOrFiles(workflow), fp_ts_1.either.fold(deploy, files => pipeable_1.pipe(pure_1.mapThese(files, impure_1.readDefinitionFromFile), fp_ts_1.either.fold(error, deploy))));
    }
    failJob(failJobRequest) {
        return this.executeOperation('failJob', () => this.grpc.failJobSync(failJobRequest));
    }
    /**
     * Return an array of task-types specified in a BPMN file.
     * @param file - Path to bpmn file.
     */
    getServiceTypesFromBpmn(files) {
        const fileArray = typeof files === 'string' ? [files] : files;
        return lib_1.BpmnParser.getTaskTypes(lib_1.BpmnParser.parseBpmn(fileArray));
    }
    /**
     * Publish a message to the broker for correlation with a workflow instance.
     * @param publishMessageRequest - The message to publish.
     */
    publishMessage(publishMessageRequest) {
        return this.executeOperation('publishMessage', () => this.grpc.publishMessageSync(lib_1.stringifyVariables(publishMessageRequest)));
    }
    /**
     * Publish a message to the broker for correlation with a workflow message start event.
     * @param publishStartMessageRequest - The message to publish.
     */
    publishStartMessage(publishStartMessageRequest) {
        /**
         * The hash of the correlationKey is used to determine the partition where this workflow will start.
         * So we assign a random uuid to balance workflow instances created via start message across partitions.
         *
         * We make the correlationKey optional, because the caller can specify a correlationKey + messageId
         * to guarantee an idempotent message.
         *
         * Multiple messages with the same correlationKey + messageId combination will only start a workflow once.
         * See: https://github.com/zeebe-io/zeebe/issues/1012 and https://github.com/zeebe-io/zeebe/issues/1022
         */
        const publishMessageRequest = {
            correlationKey: uuid_1.v4(),
            ...publishStartMessageRequest,
        };
        return this.executeOperation('publishStartMessage', () => this.grpc.publishMessageSync(lib_1.stringifyVariables(publishMessageRequest)));
    }
    resolveIncident(incidentKey) {
        return this.executeOperation('resolveIncident', () => this.grpc.resolveIncidentSync(incidentKey));
    }
    setVariables(request) {
        /*
        We allow developers to interact with variables as a native JS object, but the Zeebe server needs it as a JSON document
        So we stringify it here.
        */
        if (typeof request.variables === 'object') {
            request.variables = JSON.stringify(request.variables);
        }
        return this.executeOperation('setVariables', () => this.grpc.setVariablesSync(request));
    }
    /**
     *
     * Report a business error (i.e. non-technical) that occurs while processing a job.
     * The error is handled in the workflow by an error catch event.
     * If there is no error catch event with the specified errorCode then an incident will be raised instead.
     */
    throwError(throwErrorRequest) {
        return this.executeOperation('throwError', () => this.grpc.throwErrorSync(throwErrorRequest));
    }
    /**
     * Return the broker cluster topology
     */
    topology() {
        return this.executeOperation('topology', this.grpc.topologySync);
    }
    updateJobRetries(updateJobRetriesRequest) {
        return this.executeOperation('updateJobRetries', () => this.grpc.updateJobRetriesSync(updateJobRetriesRequest));
    }
    constructGrpcClient({ grpcConfig, logConfig, }) {
        const { grpcClient, log } = ConnectionFactory_1.ConnectionFactory.getGrpcClient({
            grpcConfig: {
                basicAuth: this.basicAuth,
                connectionTolerance: typed_duration_1.Duration.milliseconds.from(this.connectionTolerance),
                host: this.gatewayAddress,
                loglevel: this.loglevel,
                namespace: grpcConfig.namespace,
                oAuth: this.oAuth,
                options: {
                    longPoll: this.options.longPoll
                        ? typed_duration_1.Duration.milliseconds.from(this.options.longPoll)
                        : undefined,
                },
                packageName: 'gateway_protocol',
                protoPath: path.join(__dirname, '../../proto/zeebe.proto'),
                service: 'Gateway',
                stdout: this.stdout,
                tasktype: grpcConfig.tasktype,
                useTLS: this.useTLS,
            },
            logConfig,
        });
        if (grpcConfig.onConnectionError) {
            grpcClient.on(exports.ConnectionStatusEvent.ConnectionError, grpcConfig.onConnectionError);
        }
        if (grpcConfig.onReady) {
            grpcClient.on(exports.ConnectionStatusEvent.Ready, grpcConfig.onReady);
        }
        return { grpcClient: grpcClient, log };
    }
    /**
     * If this.retry is set true, the operation will be wrapped in an configurable retry on exceptions
     * of gRPC error code 14 - Transient Network Failure.
     * See: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
     * If this.retry is false, it will be executed with no retry, and the application should handle the exception.
     * @param operation A gRPC command operation
     */
    async executeOperation(operationName, operation, retries) {
        return this.retry
            ? this.retryOnFailure(operationName, operation, retries)
            : operation();
    }
    _onConnectionError() {
        var _a;
        if (!this.connected) {
            return;
        }
        this.connected = false;
        // const debounce =
        // 	this.lastConnectionError &&
        // 	new Date().valueOf() - this.lastConnectionError.valueOf() >
        // 		this.connectionTolerance / 2
        // if (!debounce) {
        (_a = this.onConnectionError) === null || _a === void 0 ? void 0 : _a.call(this);
        this.emit(exports.ConnectionStatusEvent.ConnectionError);
        // }
        // this.lastConnectionError = new Date()
    }
    /**
     * This function takes a gRPC operation that returns a Promise as a function, and invokes it.
     * If the operation throws gRPC error 14, this function will continue to try it until it succeeds
     * or retries are exhausted.
     * @param operation A gRPC command operation that may fail if the broker is not available
     */
    async retryOnFailure(operationName, operation, retries = this.maxRetries) {
        let connectionErrorCount = 0;
        return promise_retry_1.default((retry, n) => {
            if (this.closing || this.grpc.channelClosed) {
                return Promise.resolve();
            }
            if (n > 1) {
                this.logger.logError(`[${operationName}]: Attempt ${n} (max: ${this.maxRetries}).`);
            }
            return operation().catch(err => {
                // This could be DNS resolution, or the gRPC gateway is not reachable yet, or Backpressure
                const isNetworkError = err.message.indexOf('14') === 0 ||
                    err.message.indexOf('Stream removed') !== -1;
                const isBackpressure = err.message.indexOf('8') === 0 || err.code === 8;
                if (isNetworkError) {
                    if (connectionErrorCount < 0) {
                        this._onConnectionError();
                    }
                    connectionErrorCount++;
                }
                if (isNetworkError || isBackpressure) {
                    this.logger.logError(`[${operationName}]: ${err.message}`);
                    retry(err);
                }
                // The gRPC channel will be closed if close has been called
                if (this.grpc.channelClosed) {
                    return Promise.resolve();
                }
                throw err;
            });
        }, {
            forever: retries === -1,
            maxTimeout: typed_duration_1.Duration.milliseconds.from(this.maxRetryTimeout),
            retries: retries === -1 ? undefined : retries,
        });
    }
}
exports.ZBClient = ZBClient;
ZBClient.DEFAULT_CONNECTION_TOLERANCE = typed_duration_1.Duration.milliseconds.of(3000);
ZBClient.DEFAULT_MAX_RETRIES = -1; // Infinite retry
ZBClient.DEFAULT_MAX_RETRY_TIMEOUT = typed_duration_1.Duration.seconds.of(5);
ZBClient.DEFAULT_LONGPOLL_PERIOD = typed_duration_1.Duration.seconds.of(30);
//# sourceMappingURL=ZBClient.js.map