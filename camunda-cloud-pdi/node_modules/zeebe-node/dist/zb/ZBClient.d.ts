/// <reference types="node" />
import { EventEmitter } from 'events';
import { MaybeTimeDuration } from 'typed-duration';
import * as ZB from '../lib/interfaces';
import { CreateWorkflowInstanceWithResult } from '../lib/interfaces';
import * as Grpc from '../lib/interfaces-grpc';
import { Loglevel, ZBClientOptions } from '../lib/interfaces-published-contract';
import { ZBBatchWorker } from './ZBBatchWorker';
import { ZBWorker } from './ZBWorker';
export declare const ConnectionStatusEvent: {
    ConnectionError: "connectionError";
    Ready: "ready";
    Unknown: "unknown";
};
export declare class ZBClient extends EventEmitter {
    static readonly DEFAULT_CONNECTION_TOLERANCE: import("typed-duration").Milliseconds;
    private static readonly DEFAULT_MAX_RETRIES;
    private static readonly DEFAULT_MAX_RETRY_TIMEOUT;
    private static readonly DEFAULT_LONGPOLL_PERIOD;
    connectionTolerance: MaybeTimeDuration;
    connected?: boolean;
    readied: boolean;
    gatewayAddress: string;
    loglevel: Loglevel;
    onReady?: () => void;
    onConnectionError?: () => void;
    private logger;
    private closePromise?;
    private closing;
    private grpc;
    private options;
    private workerCount;
    private workers;
    private retry;
    private maxRetries;
    private maxRetryTimeout;
    private oAuth?;
    private basicAuth?;
    private useTLS;
    private stdout;
    /**
     *
     * @param options Zero-conf constructor. The entire ZBClient connection config can be passed in via the environment.
     */
    constructor(options?: ZBClientOptions);
    constructor(gatewayAddress: string, options?: ZBClientOptions);
    activateJobs<Variables = ZB.KeyedObject, CustomHeaders = ZB.KeyedObject>(request: Grpc.ActivateJobsRequest): Promise<ZB.Job[]>;
    cancelWorkflowInstance(workflowInstanceKey: string | number): Promise<void>;
    createBatchWorker<WorkerInputVariables = ZB.InputVariables, CustomHeaderShape = ZB.CustomHeaders, WorkerOutputVariables = ZB.OutputVariables>(conf: ZB.ZBBatchWorkerConfig<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>): ZBBatchWorker<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
    createWorker<WorkerInputVariables = ZB.InputVariables, CustomHeaderShape = ZB.CustomHeaders, WorkerOutputVariables = ZB.OutputVariables>(config: ZB.ZBWorkerConfig<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>): ZBWorker<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
    createWorker<WorkerInputVariables = ZB.InputVariables, CustomHeaderShape = ZB.CustomHeaders, WorkerOutputVariables = ZB.OutputVariables>(id: string | null, taskType: string, taskHandler: ZB.ZBWorkerTaskHandler<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>, options?: ZB.ZBWorkerOptions<WorkerInputVariables> & ZBClientOptions, onConnectionError?: ZB.ConnectionErrorHandler | undefined): ZBWorker<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
    createWorker<WorkerInputVariables = ZB.InputVariables, CustomHeaderShape = ZB.CustomHeaders, WorkerOutputVariables = ZB.OutputVariables>(taskType: string, taskHandler: ZB.ZBWorkerTaskHandler<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>, options?: ZB.ZBWorkerOptions<WorkerInputVariables> & ZBClientOptions, onConnectionError?: ZB.ConnectionErrorHandler | undefined): ZBWorker<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
    /**
     * Gracefully shut down all workers, draining existing tasks, and return when it is safe to exit.
     * @returns Promise
     * @memberof ZBClient
     */
    close(timeout?: number): Promise<any>;
    completeJob(completeJobRequest: Grpc.CompleteJobRequest): Promise<void>;
    createWorkflowInstance<Variables = ZB.WorkflowVariables>(bpmnProcessId: string, variables: Variables): Promise<Grpc.CreateWorkflowInstanceResponse>;
    createWorkflowInstance<Variables = ZB.WorkflowVariables>(config: {
        bpmnProcessId: string;
        variables: Variables;
        version: number;
    }): Promise<Grpc.CreateWorkflowInstanceResponse>;
    createWorkflowInstanceWithResult<Variables = ZB.WorkflowVariables, Result = ZB.OutputVariables>(config: CreateWorkflowInstanceWithResult<Variables>): Promise<Grpc.CreateWorkflowInstanceWithResultResponse<Result>>;
    createWorkflowInstanceWithResult<Variables = ZB.WorkflowVariables, Result = ZB.OutputVariables>(bpmnProcessId: string, variables: Variables): Promise<Grpc.CreateWorkflowInstanceWithResultResponse<Result>>;
    /**
     *
     * @param workflow - A path or array of paths to .bpmn files or an object describing the workflow
     */
    deployWorkflow(workflow: ZB.DeployWorkflowFiles | ZB.DeployWorkflowBuffer): Promise<Grpc.DeployWorkflowResponse>;
    failJob(failJobRequest: Grpc.FailJobRequest): Promise<void>;
    /**
     * Return an array of task-types specified in a BPMN file.
     * @param file - Path to bpmn file.
     */
    getServiceTypesFromBpmn(files: string | string[]): Promise<string[]>;
    /**
     * Publish a message to the broker for correlation with a workflow instance.
     * @param publishMessageRequest - The message to publish.
     */
    publishMessage<T = ZB.WorkflowVariables>(publishMessageRequest: Grpc.PublishMessageRequest<T>): Promise<void>;
    /**
     * Publish a message to the broker for correlation with a workflow message start event.
     * @param publishStartMessageRequest - The message to publish.
     */
    publishStartMessage<T = ZB.WorkflowVariables>(publishStartMessageRequest: Grpc.PublishStartMessageRequest<T>): Promise<void>;
    resolveIncident(incidentKey: string): Promise<void>;
    setVariables<Variables = ZB.WorkflowVariables>(request: Grpc.SetVariablesRequest<Variables>): Promise<void>;
    /**
     *
     * Report a business error (i.e. non-technical) that occurs while processing a job.
     * The error is handled in the workflow by an error catch event.
     * If there is no error catch event with the specified errorCode then an incident will be raised instead.
     */
    throwError(throwErrorRequest: Grpc.ThrowErrorRequest): Promise<void>;
    /**
     * Return the broker cluster topology
     */
    topology(): Promise<Grpc.TopologyResponse>;
    updateJobRetries(updateJobRetriesRequest: Grpc.UpdateJobRetriesRequest): Promise<void>;
    private constructGrpcClient;
    /**
     * If this.retry is set true, the operation will be wrapped in an configurable retry on exceptions
     * of gRPC error code 14 - Transient Network Failure.
     * See: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
     * If this.retry is false, it will be executed with no retry, and the application should handle the exception.
     * @param operation A gRPC command operation
     */
    private executeOperation;
    private _onConnectionError;
    /**
     * This function takes a gRPC operation that returns a Promise as a function, and invokes it.
     * If the operation throws gRPC error 14, this function will continue to try it until it succeeds
     * or retries are exhausted.
     * @param operation A gRPC command operation that may fail if the broker is not available
     */
    private retryOnFailure;
}
