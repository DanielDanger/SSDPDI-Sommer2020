"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const typed_duration_1 = require("typed-duration");
const uuid = __importStar(require("uuid"));
const lib_1 = require("../lib");
const ZBClient_1 = require("../zb/ZBClient");
const CapacityEvent = {
    Available: 'AVAILABLE',
    Empty: 'CAPACITY_EMPTY',
};
class ZBWorkerBase extends events_1.EventEmitter {
    constructor({ grpcClient, id, log, options, taskHandler, taskType, zbClient, }) {
        var _a;
        super();
        this.activeJobs = 0;
        this.pollCount = 0;
        this.cancelWorkflowOnException = false;
        this.closing = false;
        this.closed = false;
        this.id = uuid.v4();
        // Used to prevent worker from exiting when no timers active
        this.alivenessBit = 0;
        this.stalled = false;
        this.connected = true;
        this.readied = false;
        this.jobStreams = {};
        this.work = () => {
            this.logger.logInfo(`Ready for ${this.taskType}...`);
            this.grpcClient.once(ZBClient_1.ConnectionStatusEvent.Ready, () => {
                this.logger.logDebug(`Fired backup start work event.`);
                this.stalled = false;
                this.longPollLoop();
            });
            this.longPollLoop();
        };
        options = options || {};
        if (!taskType) {
            throw new Error('Missing taskType');
        }
        if (!taskHandler) {
            throw new Error('Missing taskHandler');
        }
        this.taskHandler = taskHandler;
        this.taskType = taskType;
        this.maxJobsToActivate =
            options.maxJobsToActivate || ZBWorkerBase.DEFAULT_MAX_ACTIVE_JOBS;
        this.jobBatchMinSize = Math.min((_a = options.jobBatchMinSize) !== null && _a !== void 0 ? _a : 0, this.maxJobsToActivate);
        this.timeout =
            options.timeout || ZBWorkerBase.DEFAULT_JOB_ACTIVATION_TIMEOUT;
        this.longPoll = options.longPoll;
        this.id = id || uuid.v4();
        // Set options.debug to true to count the number of poll requests for testing
        // See the Worker-LongPoll test
        this.debugMode = options.debug === true;
        this.grpcClient = grpcClient;
        const onError = () => {
            var _a, _b;
            (_a = options.onConnectionError) === null || _a === void 0 ? void 0 : _a.call(options);
            if (this.connected) {
                this.emit(ZBClient_1.ConnectionStatusEvent.ConnectionError);
                (_b = options.onConnectionError) === null || _b === void 0 ? void 0 : _b.call(options);
                this.connected = false;
                this.readied = false;
                this.stall();
            }
        };
        this.grpcClient.on(ZBClient_1.ConnectionStatusEvent.ConnectionError, onError);
        const onReady = async () => {
            var _a;
            if (!this.readied) {
                this.emit(ZBClient_1.ConnectionStatusEvent.Ready);
                (_a = options.onReady) === null || _a === void 0 ? void 0 : _a.call(options);
                this.readied = true;
                this.connected = true;
            }
        };
        this.grpcClient.on(ZBClient_1.ConnectionStatusEvent.Unknown, onReady);
        this.grpcClient.on(ZBClient_1.ConnectionStatusEvent.Ready, onReady);
        this.cancelWorkflowOnException =
            options.failWorkflowOnException || false;
        this.zbClient = zbClient;
        this.grpcClient.topologySync().catch(e => {
            // Swallow exception to avoid throwing if retries are off
            if (e.thisWillNeverHappenYo) {
                this.emit('never');
            }
        });
        this.logger = log;
        this.capacityEmitter = new events_1.EventEmitter();
        // With long polling there are periods where no timers are running. This prevents the worker exiting.
        this.keepAlive = setInterval(() => {
            this.alivenessBit = (this.alivenessBit + 1) % 1;
        }, 10000);
        this.grpcClient.on(ZBClient_1.ConnectionStatusEvent.ConnectionError, () => this.stall());
        this.work();
    }
    /**
     * Returns a promise that the worker has stopped accepting tasks and
     * has drained all current active tasks. Will reject if you try to call it more than once.
     */
    close(timeout) {
        if (this.closePromise) {
            return this.closePromise;
        }
        this.closePromise = new Promise(async (resolve) => {
            // this.closing prevents the worker from starting work on any new tasks
            this.closing = true;
            if (this.restartPollingAfterLongPollTimeout) {
                clearTimeout(this.restartPollingAfterLongPollTimeout);
            }
            if (this.activeJobs <= 0) {
                clearInterval(this.keepAlive);
                await this.grpcClient.close(timeout);
                this.grpcClient.removeAllListeners();
                Object.keys(this.jobStreams).forEach(key => {
                    var _a, _b, _c, _d;
                    (_b = (_a = this.jobStreams[key]) === null || _a === void 0 ? void 0 : _a.removeAllListeners) === null || _b === void 0 ? void 0 : _b.call(_a);
                    (_d = (_c = this.jobStreams[key]) === null || _c === void 0 ? void 0 : _c.cancel) === null || _d === void 0 ? void 0 : _d.call(_c);
                    delete this.jobStreams[key];
                    this.logger.logDebug('Removed Job Stream Listeners');
                });
                resolve();
            }
            else {
                this.capacityEmitter.once(CapacityEvent.Empty, async () => {
                    clearInterval(this.keepAlive);
                    await this.grpcClient.close(timeout);
                    this.grpcClient.removeAllListeners();
                    this.emit('close');
                    this.removeAllListeners();
                    resolve();
                });
            }
        });
        return this.closePromise;
    }
    log(msg) {
        this.logger.logInfo(msg);
    }
    debug(msg) {
        this.logger.logDebug(msg);
    }
    error(msg) {
        this.logger.logError(msg);
    }
    drainOne() {
        this.activeJobs--;
        this.logger.logDebug(`Load: ${this.activeJobs}/${this.maxJobsToActivate}`);
        if (!this.closing && this.activeJobs < this.maxJobsToActivate * 0.75) {
            this.capacityEmitter.emit(CapacityEvent.Available);
        }
        if (this.closing && this.activeJobs === 0) {
            this.capacityEmitter.emit(CapacityEvent.Empty);
        }
        // If we are closing and hit zero active jobs, resolve the closing promise.
        if (this.activeJobs <= 0 && this.closing) {
            if (this.closeCallback && !this.closed) {
                this.closeCallback();
            }
        }
    }
    handleJobs(_) {
        this.log(`This method must be declared in a class that extends this base`);
    }
    makeCompleteHandlers(thisJob) {
        const failJob = (job) => (errorMessage, retries) => this.failJob({ job, errorMessage, retries });
        const succeedJob = (job) => (completedVariables) => this.completeJob(job.key, completedVariables !== null && completedVariables !== void 0 ? completedVariables : {});
        const errorJob = (job) => (errorCode, errorMessage = '') => this.errorJob({
            errorCode,
            errorMessage,
            job,
        });
        return {
            error: errorJob(thisJob),
            failure: failJob(thisJob),
            forwarded: () => this.drainOne(),
            success: succeedJob(thisJob),
        };
    }
    failJob({ job, errorMessage, retries, }) {
        this.zbClient
            .failJob({
            errorMessage,
            jobKey: job.key,
            retries: retries !== null && retries !== void 0 ? retries : job.retries - 1,
        })
            .finally(() => {
            this.logger.logDebug(`Failed job ${job.key} - ${errorMessage}`);
            this.drainOne();
        });
    }
    completeJob(jobKey, completedVariables = {}) {
        return this.zbClient
            .completeJob({
            jobKey,
            variables: completedVariables,
        })
            .then(res => {
            this.logger.logDebug(`Completed job ${jobKey} for ${this.taskType}`);
            return res;
        })
            .catch(e => {
            this.logger.logDebug(`Completing job ${jobKey} for ${this.taskType} threw ${e.message}`);
            return e;
        })
            .finally(() => {
            this.drainOne();
        });
    }
    errorJob({ errorCode, errorMessage, job, }) {
        return this.zbClient
            .throwError({
            errorCode,
            errorMessage,
            jobKey: job.key,
        })
            .then(() => this.logger.logDebug(`Errored job ${job.key} - ${errorMessage}`))
            .catch(e => {
            this.logger.logError(`Exception while attempting to raise BPMN Error for job ${job.key} - ${errorMessage}`);
            this.logger.logError(e);
        })
            .then(() => this.drainOne());
    }
    stall() {
        if (this.restartPollingAfterStall) {
            return;
        }
        this.stalled = true;
        this.logger.logError(`Stalled on Grpc Error`);
        const timeout = 5000; // Duration.milliseconds.from(this.longPoll) + 100
        this.logger.logDebug(`Stalled. Setting timeout to ${timeout}`);
        this.restartPollingAfterStall = setTimeout(() => {
            this.stalled = false;
            this.restartPollingAfterStall = undefined;
            this.logger.logDebug(`Restart after stall timer fired ${timeout}`);
            this.longPollLoop();
        }, timeout);
        // this.grpcClient.once(ConnectionStatusEvent.Ready, () => {
        // 	this.stalled = false
        // 	this.longPollLoop()
        // })
    }
    async longPollLoop() {
        var _a, _b;
        if (this.closePromise) {
            return;
        }
        this.logger.logDebug('Activating Jobs...');
        const jobStream = await this.activateJobs();
        const id = uuid.v4();
        const start = Date.now();
        this.logger.logDebug(`Long poll loop. this.longPoll: ${typed_duration_1.Duration.value.of(this.longPoll)}`, Object.keys(jobStream)[0], start);
        if (jobStream.stream) {
            this.logger.logDebug('Stream opened...');
            this.jobStreams[id] = jobStream.stream;
            // This event happens when the server cancels the call after the deadline
            // And when it has completed a response with work
            (_b = (_a = jobStream.stream).on) === null || _b === void 0 ? void 0 : _b.call(_a, 'end', () => {
                this.logger.logDebug(`Stream ended after ${(Date.now() - start) / 1000} seconds`);
                clearTimeout(this.restartPollingAfterLongPollTimeout);
                this.jobStreams[id].removeAllListeners();
                delete this.jobStreams[id];
                this.longPollLoop();
            });
            // We do this here because activateJobs may not result in an open gRPC call
            // for example, if the worker is at capacity
            if (!this.closing) {
                const timeout = typed_duration_1.Duration.milliseconds.from(this.longPoll) + 100;
                this.logger.logDebug(`Setting timeout to ${timeout}`);
                this.restartPollingAfterLongPollTimeout = setTimeout(() => {
                    this.logger.logDebug(`Timer fired ${timeout}`);
                    this.longPollLoop();
                }, timeout);
            }
        }
        if (jobStream.atCapacity) {
            jobStream.atCapacity.once(CapacityEvent.Available, () => this.longPollLoop());
        }
        if (jobStream.error) {
            this.logger.logError(jobStream.error.message);
            setTimeout(() => this.longPollLoop(), 1000); // @TODO implement backoff
        }
    }
    async activateJobs() {
        if (this.stalled) {
            return { stalled: true };
        }
        if (this.closing) {
            return {
                closing: true,
            };
        }
        if (this.debugMode) {
            this.logger.logDebug('Activating Jobs');
        }
        let stream;
        if (this.activeJobs >= this.maxJobsToActivate - this.jobBatchMinSize) {
            this.logger.logInfo(`Worker at max capacity - ${this.taskType} has ${this.activeJobs}, a capacity of ${this.maxJobsToActivate}, and a minimum job batch size of ${this.jobBatchMinSize}.`);
            return { atCapacity: this.capacityEmitter };
        }
        const amount = this.maxJobsToActivate - this.activeJobs;
        const requestTimeout = this.longPoll || -1;
        const activateJobsRequest = {
            maxJobsToActivate: amount,
            requestTimeout,
            timeout: this.timeout,
            type: this.taskType,
            worker: this.id,
        };
        this.logger.logDebug(`Requesting ${amount} jobs with requestTimeout ${typed_duration_1.Duration.value.of(requestTimeout)}, job timeout: ${typed_duration_1.Duration.value.of(this.timeout)}`);
        try {
            stream = await this.grpcClient.activateJobsStream(activateJobsRequest);
            if (this.debugMode) {
                this.pollCount++;
            }
        }
        catch (error) {
            return {
                error,
            };
        }
        if (stream.error) {
            return { error: stream.error };
        }
        stream.on('data', (res) => {
            // If we are closing, don't start working on these jobs. They will have to be timed out by the server.
            if (this.closing) {
                return;
            }
            const jobs = res.jobs.map(job => lib_1.parseVariablesAndCustomHeadersToJSON(job));
            this.activeJobs += jobs.length;
            this.handleJobs(jobs);
        });
        return { stream };
    }
}
exports.ZBWorkerBase = ZBWorkerBase;
ZBWorkerBase.DEFAULT_JOB_ACTIVATION_TIMEOUT = typed_duration_1.Duration.seconds.of(60);
ZBWorkerBase.DEFAULT_MAX_ACTIVE_JOBS = 32;
//# sourceMappingURL=ZBWorkerBase.js.map