{
  "_args": [
    [
      {
        "raw": "zeebe-node",
        "scope": null,
        "escapedName": "zeebe-node",
        "name": "zeebe-node",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "C:\\Users\\Tobias\\OneDrive\\Dokumente\\Hochschule Master\\PDI\\Camunda\\camunda-cloud-pdi"
    ]
  ],
  "_from": "zeebe-node",
  "_hasShrinkwrap": false,
  "_id": "zeebe-node@0.23.3",
  "_location": "/zeebe-node",
  "_nodeVersion": "11.10.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/zeebe-node_0.23.3_1592282525600_0.393625263733163"
  },
  "_npmUser": {
    "name": "jfilmer-creditsense",
    "email": "jfilmer@creditsense.com.au"
  },
  "_npmVersion": "6.7.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "zeebe-node",
    "scope": null,
    "escapedName": "zeebe-node",
    "name": "zeebe-node",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/zeebe-node/-/zeebe-node-0.23.3.tgz",
  "_shasum": "63c81c35475bff983e8c23d5b40a014f51531511",
  "_shrinkwrap": null,
  "_spec": "zeebe-node",
  "_where": "C:\\Users\\Tobias\\OneDrive\\Dokumente\\Hochschule Master\\PDI\\Camunda\\camunda-cloud-pdi",
  "author": {
    "name": "Josh Wulf",
    "email": "josh@magikcraft.io"
  },
  "bin": {
    "zeebe-node": "./bin/zeebe-node"
  },
  "bugs": {
    "url": "https://github.com/creditsenseau/zeebe-client-node-js/issues"
  },
  "contributors": [
    {
      "name": "Timothy Colbert"
    },
    {
      "name": "Jarred Filmer"
    },
    {
      "name": "Colin Raddatz"
    },
    {
      "name": "Olivier Albertini"
    },
    {
      "name": "Patrick Dehn"
    }
  ],
  "dependencies": {
    "@grpc/grpc-js": "^1.0.4",
    "@grpc/proto-loader": "^0.5.3",
    "chalk": "^2.4.2",
    "console-stamp": "^0.2.7",
    "dayjs": "^1.8.15",
    "debug": "^4.1.1",
    "fast-xml-parser": "^3.12.12",
    "fp-ts": "^2.5.1",
    "got": "^9.6.0",
    "grpc": "^1.24.3",
    "long": "^4.0.0",
    "promise-retry": "^1.1.1",
    "segfault-handler": "^1.3.0",
    "stack-trace": "0.0.10",
    "typed-duration": "^1.0.12",
    "uuid": "^3.3.2"
  },
  "description": "A Node.js client library for the Zeebe Microservices Orchestration Engine.",
  "devDependencies": {
    "@sitapati/testcontainers": "^2.8.1",
    "@types/debug": "0.0.31",
    "@types/got": "^9.6.9",
    "@types/jest": "^25.2.3",
    "@types/node": "^10.17.17",
    "@types/promise-retry": "^1.1.3",
    "@types/stack-trace": "0.0.29",
    "@types/uuid": "^3.4.4",
    "delay": "^4.3.0",
    "husky": "^1.3.1",
    "jest": "^26.0.1",
    "lint-staged": "^8.1.5",
    "prettier": "^1.19.1",
    "remark": "^10.0.1",
    "remark-cli": "^6.0.1",
    "remark-lint": "^6.0.4",
    "remark-preset-lint-recommended": "^3.0.2",
    "ts-jest": "^26.1.0",
    "tsc-watch": "^1.0.31",
    "tslint": "^5.16.0",
    "tslint-config-prettier": "^1.18.0",
    "typedoc": "^0.16.0",
    "typedoc-plugin-sourcefile-url": "^1.0.6",
    "typescript": "^3.8.3"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-hap/Cr8Z7IXx1eINvKHD3PXhX0L0TFT4/72PaqISKi4pDcRoh0gUOZ/Mnt2NVfTaiNfYMR1488cj4tSKXLnTrw==",
    "shasum": "63c81c35475bff983e8c23d5b40a014f51531511",
    "tarball": "https://registry.npmjs.org/zeebe-node/-/zeebe-node-0.23.3.tgz",
    "fileCount": 107,
    "unpackedSize": 627986,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe6E2eCRA9TVsSAnZWagAAlB4P/3LTLMVmlhPOaGks2nAV\nUEReXpPSFYIVT6l7vhq7ENdeqw/jRA3RO0tmPd5d9DrisQnP6HVBLruWuzlr\nh0V4OqC+jmdRvgoxyeBqJB4omNWKdB9IVtoNrlSDivxkw4CCvnfUaGyXcYGx\nGjybQnjqBG58Y5iIqW8+tOkqnfAPOxyn53D2/Mcsb9OnKDeVtqCclawNnRJD\nyXMKaWSUCOwDKG0lJdl0P1fk1HySCB3vQEp0RpVyuGaJIWsKvDeNyqUmrWhM\nZE5DjKg5+MSvRAZKtos3YClBri0VS2cH7a3pz+yOifhKfAnHEvlav317yjfE\nbGPLCHWr2QCFvTGOrv83/gekdQ2JmUMnzCRkdqSu7cO8P9Pg3O9wuXEYzENk\ntrBm7Q2dh3d+M4KrM5qQKQ66Xu/MgtjqN2G6zPyO8h49uD/Qtp4IAxrWV09G\ndJ67w8W5mcWtl7p6Cbk24L2fzDO6Z/3FatJHtbBjNTVmU0eIgjcQo71IBAj+\nmbIofjLC2bJjVHQsDLH8q3Pvf0DtEAgeYTCfcy1dPPKOQWHeIctcV6gOTUm0\nQ0eFxsbqjtsmENDPY4dCuTbNfiR09+UHXH5fUuVRuOoMfPq6RSzX+55RTQGH\nR0RIzveOLNoXkTxCWu7Xf9uF5OxBP9mD/6po4+lY+YtlQwfarhZjvI8zGHeK\n7PJQ\r\n=r6Gr\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "gitHead": "af49c5e6509a18e9bd6b8aa923ea15f9ff20b58c",
  "homepage": "https://creditsenseau.github.io/zeebe-client-node-js/",
  "husky": {
    "hooks": {
      "pre-commit": "npm test && npm run test:disconnect && npm run-script build && lint-staged"
    }
  },
  "keywords": [
    "zeebe",
    "zeebe.io",
    "microservices",
    "orchestration",
    "bpmn",
    "conductor",
    "camunda",
    "Netflix",
    "workflow",
    "Uber",
    "Cadence"
  ],
  "license": "Apache-2.0",
  "lint-staged": {
    "*.{md,markdown}": [
      "prettier --write",
      "remark",
      "git add"
    ],
    "*.{json,css,html,yaml,yml}": [
      "prettier --write",
      "git add"
    ],
    "*.{ts,tsx,js,jsx}": [
      "prettier --write",
      "tslint -c tslint.json --fix",
      "git add"
    ]
  },
  "main": "dist/index.js",
  "maintainers": [
    {
      "name": "jfilmer-creditsense",
      "email": "jfilmer@creditsense.com.au"
    },
    {
      "name": "jwulf-creditsense",
      "email": "jwulf@creditsense.com.au"
    }
  ],
  "name": "zeebe-node",
  "optionalDependencies": {},
  "readme": "# Zeebe Node.js Client\n\n[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n[![CircleCI](https://circleci.com/gh/creditsenseau/zeebe-client-node-js/tree/master.svg?style=svg)](https://circleci.com/gh/creditsenseau/zeebe-client-node-js/tree/master)\n![Test on Camunda Cloud](https://github.com/jwulf/zeebe-client-node-js/workflows/Test%20on%20Camunda%20Cloud/badge.svg)\n\nThis is a Node.js gRPC client for [Zeebe](https://zeebe.io). It is written in TypeScript and transpiled to JavaScript in the `dist` directory.\n\nComprehensive API documentation is available [online](https://creditsenseau.github.io/zeebe-client-node-js/).\n\nSee [CHANGELOG.md](./CHANGELOG.md) to see what has changed with each release.\n\nDocker-compose configurations for Zeebe are available at [zeebe-docker-compose](https://github.com/zeebe-io/zeebe-docker-compose).\n\nGet a hosted instance of Zeebe on [Camunda Cloud](https://camunda.io).\n\n## Table of Contents\n\n-   [ Versioning ](#versioning)\n-   [ gRPC Implementation ](#grpc-implementation)\n-   [ Type difference from other Zeebe clients ](#type-difference)\n-   [ A note on representing timeout durations ](#time-duration)\n\n**Quick Start**\n\n-   [ Install ](#install)\n-   [ Get Broker Topology ](#get-topology)\n-   [ Deploy a workflow ](#deploy-workflow)\n\n**Connection Behaviour**\n\n-   [ Client-side gRPC retry in ZBClient ](#client-side-retry)\n-   [ onReady(), onConnectionError(), and connected ](#on-ready)\n-   [ Initial Connection Tolerance ](#initial-connection-tolerance)\n\n**Connecting to a Broker**\n\n-   [ TLS ](#tls)\n-   [ OAuth ](#oauth)\n-   [ Basic Auth ](#basic-auth)\n-   [ Camunda Cloud ](#camunda-cloud)\n-   [ Zero-conf constructor ](#zero-conf)\n\n**Job Workers**\n\n-   [ Job Workers](#job-workers)\n-   [ The `ZBWorker` Job Worker ](#create-zbworker)\n-   [ Unhandled Exceptions in Task Handlers ](#unhandled-exceptions)\n-   [ Completing tasks with success, failure, error, or forwarded ](#complete-tasks)\n-   [ Working with Workflow Variables and Custom Headers ](#working-with-variables)\n-   [ Constraining the Variables Fetched by the Worker ](#fetch-variable)\n-   [ The \"Decoupled Job Completion\" pattern ](#decoupled-complete)\n-   [ The `ZBBatchWorker` Job Worker ](#zbbatchworker)\n-   [ Long polling ](#long-polling)\n\n**Client Commands**\n\n-   [ Start a Workflow Instance ](#start-workflow)\n-   [ Start a Workflow Instance of a specific version of a Workflow definition ](#start-specific-version)\n-   [ Start a workflow instance and await the workflow outcome ](#start-await)\n-   [ Publish a Message ](#publish-message)\n-   [ Publish a Start Message ](#publish-start-message)\n-   [ Activate Jobs ](#activate-jobs)\n\n**Other Concerns**\n\n-   [ Graceful Shutdown ](#graceful-shutdown)\n-   [ Logging ](#logging)\n\n**Programming with Safety**\n\n-   [ Generating TypeScript constants for BPMN Models ](#generate-constants)\n-   [ Generating code from a BPM Model file ](#generate-code)\n-   [ Writing Strongly-typed Job Workers ](#strongly-typed)\n-   [ Run-time Type Safety ](#run-time-safety)\n\n**Development of the Library itself**\n\n-   [ Developing Zeebe Node ](#developing)\n    -   [ Tests ](#tests)\n    -   [ Writing Tests ](#writing-tests)\n-   [ Contributors ](#contributors)\n\n<a name = \"versioning\"></a>\n\n## Versioning\n\nTo enable that the client libraries can be easily supported to the Zeebe server we map the version numbers, so that Major, Minor match the server application. Patches are independent and indicate client updates.\n\nNPM Package version 0.23.x supports Zeebe 0.22.x and above\n\nNPM Package version 0.22.x supports Zeebe 0.22.x\n\nNPM Package version 0.21.x supports Zeebe 0.21.x\n\n<a name=\"grpc-implementation\"></a>\n\n## gRPC Implementation\n\nThe Zeebe Node client uses the C gRPC client implementation [grpc-node](https://github.com/grpc/grpc-node) by default.\n\nFrom 0.23.3, you can opt-in to use the pure JavaScript implementation [@grpc/grpc-js](https://www.npmjs.com/package/@grpc/grpc-js), to assist us in testing it.\n\nTo activate the pure JavaScript implementation, set `ZEEBE_NODE_PUREJS=true`.\n\nPlease report any issues in [GitHub](https://github.com/creditsenseau/zeebe-client-node-js/issues).\n\n<a name = \"type-difference\"></a>\n\n## Type difference from other Zeebe clients\n\nProtobuf fields of type `int64` are serialised as type string in the Node library. These fields are serialised as numbers (long) in the Go and Java client. See [grpc/#7229](https://github.com/grpc/grpc/issues/7229) for why the Node library serialises them as string. The Workflow instance key, and other fields that are of type long in other client libraries, are type string in this library. Fields of type `int32` are serialised as type number in the Node library.\n\n<a name = \"time-duration\"></a>\n\n## A note on representing timeout durations\n\nAll timeouts are ultimately communicated in _milliseconds_. They can be specified using the primitive type `number`, and this is always a _number of milliseconds_.\n\nAll timeouts in the client library can _also_, optionally, be specified by a time value that encodes the units, using the [typed-durations](https://www.npmjs.com/package/typed-duration) package. You can specify durations for timeouts like this:\n\n```\nconst { Duration } = require('zeebe-node')\n\nconst timeoutS = Duration.seconds.of(30) // 30s timeout\nconst timeoutMs = Duration.milliseconds.of(30000) // 30s timeout in milliseconds\n```\n\nUsing the value types makes your code more semantically specific.\n\nThere are four timeouts to take into account.\n\nThe first is the job `timeout`. This is the amount of time that the broker allocates exclusive responsibility for a job to a worker instance. By default, this is 60 seconds. This is the default value set by this client library. See \"[Job Workers](#job-workers)\".\n\nThe second is the `requestTimeout`. Whenever the client library sends a gRPC command to the broker, it has an explicit or implied `requestTimeout`. This is the amount of time that the gRPC gateway will wait for a response from the broker cluster before returning a `4 DEADLINE` gRPC error response.\n\nIf no `requestTimeout` is specified, then the configured timeout of the broker gateway is used. Out of the box, this is 15 seconds by default.\n\nThe most significant use of the `requestTimeout` is when using the `createWorkflowInstanceWithResult` command. If your workflow will take longer than 15 seconds to complete, you should specify a `requestTimeout`. See \"[Start a Workflow Instance and await the Workflow Outcome](#start-await)\".\n\nThe third is the `longpoll` duration. This is the amount of time that the job worker holds a long poll request to activate jobs open.\n\nThe final one is the maximum back-off delay in client-side gRPC command retries. See \"[Client-side gRPC retry in ZBClient](#client-side-retry)\".\n\n## Quick Start\n\n<a name = \"install\"></a>\n\n## Install\n\n### Add the Library to your Project\n\n```bash\nnpm i zeebe-node\n```\n\n<a name = \"get-topology\"></a>\n\n### Get Broker Topology\n\n```javascript\nconst ZB = require('zeebe-node')\n\nvoid (async () => {\n\tconst zbc = new ZB.ZBClient('localhost:26500')\n\tconst topology = await zbc.topology()\n\tconsole.log(JSON.stringify(topology, null, 2))\n})()\n```\n\n<a name = \"deploy-workflow\"></a>\n\n### Deploy a workflow\n\n```javascript\nconst ZB = require('zeebe-node')\nconst fs = require('fs')\n\nvoid (async () => {\n\tconst zbc = new ZB.ZBClient() // localhost:26500 || ZEEBE_GATEWAY_ADDRESS\n\n\tconst res = await zbc.deployWorkflow('./domain-mutation.bpmn')\n\tconsole.log(res)\n\n\t// Deploy multiple with an array of filepaths\n\tawait zbc.deployWorkflow(['./wf1.bpmn', './wf2.bpmn'])\n\n\tconst buffer = fs.readFileSync('./wf3.bpmn')\n\n\t// Deploy from an in-memory buffer\n\tawait zbc.deployWorkflow({ definition: buffer, name: 'wf3.bpmn' })\n})()\n```\n\n## Connection Behaviour\n\n<a name = \"client-side-retry\"></a>\n\n### Client-side gRPC retry in ZBClient\n\nIf a gRPC command method fails in the ZBClient - such as `ZBClient.deployWorkflow` or `ZBClient.topology()`, the underlying gRPC library will throw an exception.\n\nIf no workers have been started, this can be fatal to the process if it is not handled by the application logic. This is especially an issue when a worker container starts before the Zeebe gRPC gateway is available to service requests, and can be inconsistent as this is a race condition.\n\nTo mitigate against this, the Node client implements some client-side gRPC operation retry logic by default. This can be configured, including disabled, via configuration in the client constructor.\n\n-   Operations retry, but only for [gRPC error codes 8 and 14](https://github.com/grpc/grpc/blob/master/doc/statuscodes.md) - indicating resource exhaustion (8) or transient network failure (14). Resource exhaustion occurs when the broker starts backpressure due to latency because of load. Network failure can be caused by passing in an unresolvable gateway address (`14: DNS Resolution failed`), or by the gateway not being ready yet (`14: UNAVAILABLE: failed to connect to all addresses`).\n-   Operations that fail for other reasons, such as deploying an invalid bpmn file or cancelling a workflow that does not exist, do not retry.\n-   Retry is enabled by default, and can be disabled by passing { retry: false } to the client constructor.\n-   `maxRetries` and `maxRetryTimeout` are also configurable through the constructor options. By default, if not supplied, the values are:\n\n```TypeScript\nconst { ZBClient, Duration } = require('zeebe-node')\n\nconst zbc = new ZBClient(gatewayAddress, {\n    retry: true,\n    maxRetries: -1, // infinite retries\n    maxRetryTimeout: Duration.seconds.of(5)\n})\n```\n\nRetry is provided by [promise-retry](https://www.npmjs.com/package/promise-retry), and the back-off strategy is simple ^2.\n\nAdditionally, the gRPC Client will continually reconnect when in a failed state, such as when the gateway goes away due to pod rescheduling on Kubernetes.\n\n<a name = \"eager-connection\"></a>\n\n### Eager Connection\n\nThe ZBClient eagerly connects to the broker by issuing a topology command in the constructor. This allows you an onReady event to be emitted. You can disable this (for example, for testing without a broker), by either passing `eagerConnection: false` to the client constructor options, or setting the environment variable `ZEEBE_NODE_EAGER_CONNECTION` to `false`.\n\n<a name = \"on-ready\"></a>\n\n### onReady(), onConnectionError(), and connected\n\nThe client has a `connected` property that can be examined to determine if it has a gRPC connection to the gateway.\n\nThe client and the worker can take an optional `onReady()` and `onConnectionError()` handler in their constructors, like this:\n\n```TypeScript\nconst { ZBClient, Duration } = require('zeebe-node')\n\nconst zbc = new ZBClient({\n\tonReady: () => console.log(`Connected!`),\n\tonConnectionError: () => console.log(`Disconnected!`)\n})\n\nconst zbWorker = zbc.createWorker({\n    taskType: 'demo-service',\n\ttaskHandler: handler,\n    onReady: () => console.log(`Worker connected!`),\n    onConnectionError: () => console.log(`Worker disconnected!`)\n})\n```\n\nThese handlers are called whenever the gRPC channel is established or lost. As the grpc channel will often \"jitter\" when it is lost (rapidly emitting READY and ERROR events at the transport layer), there is a `connectionTolerance` property that determines how long the connection must be in a connected or failed state before the handler is called. By default this is 3000ms.\n\nYou can specify another value either in the constructor or via an environment variable.\n\nTo specify it via an environment variable, set `ZEEBE_CONNECTION_TOLERANCE` to a number of milliseconds.\n\nTo set it via the constructor, specify a value for `connectionTolerance` like this:\n\n```TypeScript\nconst { ZBClient, Duration } = require('zeebe-node')\n\nconst zbc = new ZBClient({\n\tonReady: () => console.log(`Connected!`),\n\tonConnectionError: () => console.log(`Disconnected!`),\n\tconnectionTolerance: 5000 // milliseconds\n})\n\nconst zbWorker = zbc.createWorker({\n\ttaskType: 'demo-service',\n\ttaskHandler: handler,\n    onReady: () => console.log(`Worker connected!`),\n    onConnectionError: () => console.log(`Worker disconnected!`),\n    connectionTolerance: Duration.seconds.of(3.5)\n})\n```\n\nAs well as the callback handlers, the client and workers extend the [`EventEmitter`](https://nodejs.org/api/events.html#events_class_eventemitter) class, and you can attach listeners to them for the 'ready' and 'connectionError' events:\n\n```TypeScript\nconst { ZBClient, Duration } = require('zeebe-node')\n\nconst zbc = new ZBClient()\n\nconst zbWorker = zbc.createWorker({\n\ttaskType: 'demo-service',\n\ttaskHandler: handler,\n    connectionTolerance: Duration.seconds.of(3.5)\n})\n\nzbWorker.on('ready', () => console.log(`Worker connected!`))\nzbWorker.on('connectionError', () => console.log(`Worker disconnected!`))\n```\n\n<a href = \"initial-connection-tolerance\" >\n\n### Initial Connection Tolerance\n\nSome broker connections can initially emit error messages - for example: when connecting to Camunda Cloud, during TLS negotiation and OAuth authentication, the eager commands used to detect connection status will fail, and the library will report connection errors.\n\nSince this is expected behaviour - a _characteristic of that particular connection_ - the library has a configurable \"_initial connection tolerance_\". This is a number of milliseconds representing the expected window in which these errors will occur on initial connection.\n\nIf the library detects that you are connecting to Camunda Cloud, it sets this window to five seconds (5000 milliseconds). In some environments and under some conditions this may not be sufficient (like connecting to Camunda Cloud from your apartment Wi-fi in South Brisbane, Australia on a rainy day while the microwave link to the next suburb's ADSL exchange is degraded).\n\nYou can set an explicit value for this using the environment variable `ZEEBE_INITIAL_CONNECTION_TOLERANCE`, set to a number of milliseconds.\n\nThe effect of this setting is to suppress connection errors during this window, and only report them if the connection did not succeed by the end of the window.\n\n## Connecting to a Broker\n\n<a name = \"tls\"></a>\n\n### TLS\n\nThe Node client does not use TLS by default.\n\nEnable a secure connection by setting `useTLS: true`:\n\n```typescript\nconst { ZBClient } = require('zeebe-node')\n\nconst zbc = new ZBClient(tlsProxiedGatewayAddress, {\n\tuseTLS: true,\n})\n```\n\nVia environment variable:\n\n```bash\nZEEBE_SECURE_CONNECTION=true\n```\n\n<a name = \"oauth\"></a>\n\n### OAuth\n\nIn case you need to connect to a secured endpoint with OAuth, you can pass in OAuth credentials. This will enable TLS (unless you explicitly disable it with `useTLS: false`), and handle the OAuth flow to get / renew a JWT:\n\n```typescript\nconst { ZBClient } = require('zeebe-node')\n\nconst zbc = new ZBClient(\"my-secure-broker.io:443\", {\n\toAuth: {\n\t\turl: \"https://your-auth-endpoint/oauth/token\",\n\t\taudience: \"my-secure-broker.io\",\n\t\tclientId: \"myClientId\",\n\t\tclientSecret:\n\t\t\"randomClientSecret\",\n\t\tcacheOnDisk: true\n\t}\n}\n```\n\nThe `cacheOnDisk` option will cache the token on disk in `$HOME/.camunda`, which can be useful in development if you are restarting the service frequently, or are running in a serverless environment, like AWS Lambda.\n\nIf the cache directory is not writable, the ZBClient constructor will throw an exception. This is considered fatal, as it can lead to denial of service or hefty bills if you think caching is on when it is not.\n\n<a name = \"basic-auth\"></a>\n\n## Basic Auth\n\nIf you put a proxy in front of the broker with basic auth, you can pass in a username and password:\n\n```typescript\nconst { ZBClient } = require('zeebe-node')\n\nconst zbc = new ZBClient(\"my-broker-with-basic-auth.io:443\", {\n\tbasicAuth: {\n\t\tusername: \"user1\",\n\t\tpassword: \"secret\",\n\t},\n\tuseTLS: true\n}\n```\n\nBasic Auth will also work without TLS.\n\n<a name = \"camunda-cloud\"></a>\n\n### Camunda Cloud\n\n[Camunda Cloud](https://camunda.io) is a hosted SaaS instance of Zeebe. The easiest way to connect is to use the [Zero-conf constructor](#zero-conf) with the Client Credentials from the Camunda Cloud console as environment variables.\n\nYou can also connect to Camunda Cloud by using the `camundaCloud` configuration option, using the `clusterId`, `clientSecret`, and `clientId` from the Camunda Cloud Console, like this:\n\n```typescript\nconst { ZBClient } = require('zeebe-node')\n\nconst zbc = new ZBClient({\n\tcamundaCloud: {\n\t\tclientId,\n\t\tclientSecret,\n\t\tclusterId,\n\t},\n})\n```\n\nThat's it! Under the hood, the client lib will construct the OAuth configuration for Camunda Cloud and set the gateway address and port for you.\n\n<a name = \"zero-conf\"></a>\n\n## Zero-Conf constructor\n\nThe ZBClient has a 0-parameter constructor that takes the config from the environment. This is useful for injecting secrets into your app via the environment, and switching between development and production environments with no change to code.\n\nTo use the zero-conf constructor, you create the client like this:\n\n```typescript\nconst { ZBClient } = require('zeebe-node')\n\nconst zbc = new ZBClient()\n```\n\nWith no relevant environment variables set, it will default to localhost on the default port with no TLS.\n\nThe following environment variable configurations are possible with the Zero-conf constructor:\n\nCamunda Cloud:\n\n```\nZEEBE_ADDRESS\nZEEBE_AUTHORIZATION_SERVER_URL\nZEEBE_CLIENT_SECRET\nZEEBE_CLIENT_ID\n```\n\nSelf-hosted or local broker (no TLS or OAuth):\n\n```\nZEEBE_ADDRESS\n```\n\nSelf-hosted or local broker with OAuth + TLS:\n\n```\nZEEBE_CLIENT_ID\nZEEBE_CLIENT_SECRET\nZEEBE_TOKEN_AUDIENCE\nZEEBE_AUTHORIZATION_SERVER_URL\nZEEBE_ADDRESS\n```\n\nBasic Auth:\n\n```\nZEEBE_BASIC_AUTH_PASSWORD\nZEEBE_BASIC_AUTH_USERNAME\n```\n\n<a name =\"job-workers\"></a>\n\n## Job Workers\n\n### Types of Job Workers\n\nThere are two different types of job worker provided by the Zeebe Node client:\n\n-   The `ZBWorker` - this worker operates on individual jobs.\n-   The `ZBBatchWorker` - this worker batches jobs on the client, to allow you to batch operations that pool resources. (_This worker was introduced in 0.23.0 of the client_).\n\nMuch of the information in the following [`ZBWorker` section](#create-zbworker) applies also to the `ZBBatchWorker`. The `ZBBatchWorker` section covers the features that differ from the `ZBWorker`.\n\n<a name = \"create-zbworker\"></a>\n\n### The `ZBWorker` Job Worker\n\nThe `ZBWorker` takes a _job handler function_ that is invoked for each job. It is invoked as soon as the worker retrieves a job from the broker. The worker can retrieve any number of jobs in a response from the broker, and the handler is invoked for each one, independently.\n\nThe simplest signature for a worker takes a string task type, and a job handler function.\n\nThe job handler receives the job object, a callback that it can use to complete or fail the job, and a reference to the worker itself, which you can use to log using the worker's configured logger (See [Logging](#logging)).\n\n```javascript\nconst ZB = require('zeebe-node')\n\nconst zbc = new ZB.ZBClient()\n\nconst zbWorker = zbc.createWorker('demo-service', handler)\n\nfunction handler(job, complete, worker) {\n\tworker.log('Task variables', job.variables)\n\n\t// Task worker business logic goes here\n\tconst updateToBrokerVariables = {\n\t\tupdatedProperty: 'newValue',\n\t}\n\n\tcomplete.success(updateToBrokerVariables)\n}\n```\n\nHere is an example job:\n\n```javascript\n\n{ key: '578',\n  type: 'demo-service',\n  jobHeaders:\n   { workflowInstanceKey: '574',\n     bpmnProcessId: 'test-process',\n     workflowDefinitionVersion: 1,\n     workflowKey: '3',\n     elementId: 'ServiceTask_0xdwuw7',\n     elementInstanceKey: '577' },\n  customHeaders: '{}',\n  worker: 'test-worker',\n  retries: 3,\n  deadline: '1546915422636',\n  variables: { testData: 'something' } }\n\n```\n\nThe worker can be configured with options. To do this, you should use the object parameter constructor.\n\nShown below are the defaults that apply if you don't supply them:\n\n```javascript\nconst { ZBClient, Duration } = require('zeebe-node')\n\nconst zbc = new ZBClient()\n\nconst zbWorker = zbc.createWorker({\n\ttaskType: 'demo-service',\n    taskHandler: handler,\n    // the number of simultaneous tasks this worker can handle\n    maxJobsToActivate: 32,\n    // the amount of time the broker should allow this worker to complete a task\n    timeout: Duration.seconds.of(30),\n    // One of 'DEBUG', 'INFO', 'NONE'\n    loglevel: 'INFO',\n    // Called when the connection to the broker cannot be established, or fails\n    onConnectionError: () => zbWorker.log('Disconnected')\n    // Called when the connection to the broker is (re-)established\n    onReady: () => zbWorker.log('Connected.')\n})\n```\n\n<a name = \"unhandled-exceptions\"></a>\n\n#### Unhandled Exceptions in Task Handlers\n\n_Note: this behaviour is for the ZBWorker only. The ZBBatchWorker does not manage this._\n\nWhen a task handler throws an unhandled exception, the library will fail the job. Zeebe will then retry the job according to the retry settings of the task. Sometimes you want to halt the entire workflow so you can investigate. To have the library cancel the workflow on an unhandled exception, pass in `{failWorkflowOnException: true}` to the `createWorker` call:\n\n```typescript\nconst { ZBClient } = require('zeebe-node')\n\nconst zbc = new ZBClient()\n\nzbc.createWorker('console-log', maybeFaultyHandler, {\n\tfailWorkflowOnException: true,\n})\n```\n\n<a name = \"complete-tasks\"></a>\n\n### Completing tasks with success, failure, error, or forwarded\n\nTo complete a task, the task worker handler function receives a `complete` parameter. The complete object has `success`, `failure`, and `error` methods.\n\nCall `complete.success()` passing in a optional plain old JavaScript object (POJO) - a key:value map. These are variable:value pairs that will be used to update the workflow state in the broker. They will be merged with existing values. You can set an existing key to `null` or `undefined`, but there is no way to delete a key.\n\nCall `complete.failure()` to fail the task. You must pass in a string message describing the failure. The client library decrements the retry count, and the broker handles the retry logic. If the failure is a hard failure and should cause an incident to be raised in Operate, then pass in `0` for the optional second parameter, `retries`:\n\n```javascript\ncomplete.failure('This is a critical failure and will raise an incident', 0)\n```\n\nCall `complete.error()` to trigger a BPMN error throw event. You must pass in a string error code for the error code, and you can pass an optional error message as the second parameter. If no BPMN error catch event exists for the error code, an incident will be raised.\n\nCall `complete.forwarded()` to release worker capacity to handle another job, without completing the job in any way with the Zeebe broker. This method supports the _decoupled job completion_ pattern. In this pattern, the worker forwards the job to another system - a lambda or a RabbitMQ queue. Some other process is ultimately responsible for completing the job.\n\n<a name = \"working-with-variables\"></a>\n\n## Working with Workflow Variables and Custom Headers\n\nWorkflow variables are available in your worker job handler callback as `job.variables`, and any custom headers are available as `job.customHeaders`.\n\nThese are read-only JavaScript objects in the Zeebe Node client. However, they are not stored that way in the broker.\n\nBoth workflow variables and custom headers are stored in the broker as a dictionary of named strings. That means that the variables and custom headers are JSON.parsed in the Node client when it fetches the job, and any update passed to the `success()` function is JSON.stringified.\n\nIf you accidentally pass in a circular JSON structure to `complete()` - like, for example the response object from an HTTP call - it will throw, as this cannot be serialised to a string.\n\nTo update a key deep in the object structure of a workflow variable, you can use the [deepmerge utility](https://www.npmjs.com/package/deepmerge):\n\n```TypeScript\nconst merge = require('deepmerge')\nconst { ZBClient } = require('zeebe-node')\n\nconst zbc = new ZBClient()\n\nzbc.createWorker('some-task', (job, complete) => {\n    const { people } = job.variables\n    // update bob's age, keeping all his other properties the same\n    complete.success(merge(people, { bob: { age: 23 } }))\n})\n```\n\nWhen setting custom headers in BPMN tasks, while designing your model, you can put stringified JSON as the value for a custom header, and it will show up in the client as a JavaScript object.\n\nWorkflow variables and custom headers are untyped in the Zeebe broker, however the Node client in TypeScript mode provides the option to type them to provide safety. You can type your worker as `any` to turn that off:\n\n```TypeScript\n// No type checking - totally dynamic and unchecked\nzbc.createWorker<any>({\n    taskType: 'yolo-jobs',\n    taskHandler: (job, complete, worker) => {\n        worker.log(`Look ma - ${job.variables.anything.goes.toUpperCase()}`)\n        complete.success({what: job.variables.could.possibly.go.wrong})\n    }\n})\n```\n\nSee the section [Writing Strongly-typed Job Workers](#strongly-typed) for more details.\n\n<a name = \"fetch-variables\"></a>\n\n## Constraining the Variables Fetched by the Worker\n\nSometimes you only need a few specific workflow variables to service a job. One way you can achieve constraint on the workflow variables received by a worker is by using [input variable mappings](https://docs.zeebe.io/reference/variables.html#inputoutput-variable-mappings) on the task in the model.\n\nYou can also use the `fetchVariable` parameter when creating a worker. Pass an array of strings, containing the names of the variables to fetch, to the `fetchVariable` parameter when creating a worker. Here is an example, in JavaScript:\n\n```javascript\nzbc.createWorker({\n\ttaskType: 'process-favorite-albums',\n\ttaskHandler: (job, complete, worker) => {\n\t\tconst { name, albums } = job.variables\n\t\tworker.log(`${name} has the following albums: ${albums.join(', ')}`)\n\t\tcomplete.success()\n\t},\n\tfetchVariable: ['name', 'albums'],\n})\n```\n\nIf you are using TypeScript, you can supply an interface describing the workflow variables, and parameterize the worker:\n\n```TypeScript\ninterface Variables {\n    name: string\n    albums: string[]\n}\n\nzbc.createWorker<Variables>({\n    taskType: 'process-favorite-albums',\n    taskHandler: (job, complete, worker) => {\n        const { name, albums = [] } = job.variables\n        worker.log(`${name} has the following albums: ${albums?.join?.(', ')}`)\n        complete.success()\n    },\n    fetchVariable: ['name', 'albums'],\n})\n```\n\nThis parameterization does two things:\n\n-   It informs the worker about the expected types of the variables. For example, if `albums` is a string, calling `join` on it will fail at runtime. Providing the type allows the compiler to reason about the valid methods that can be applied to the variables.\n-   It allows the type-checker to pick up spelling errors in the strings in `fetchVariable`, by comparing them with the Variables typing.\n\nNote, that this does not protect you against run-time exceptions where your typings are incorrect, or the payload simply does not match the definition that you provided.\n\nSee the section [ Writing Strongly-typed Job Workers ](#strongly-typed) for more details on run-time safety.\n\nYou can turn off the type-safety by typing the worker as `any`:\n\n```TypeScript\nzbc.createWorker<any>({\n    taskType: 'process-favorite-albums',\n    taskHandler: (job, complete, worker) => {\n        const { name, albums = [] } = job.variables\n        // TS 3.7 safe access to .join _and_ safe call, to prevent run-time exceptions\n        worker.log(`${name} has the following albums: ${albums?.join?.(', ')}`)\n        complete.success()\n    },\n    fetchVariable: ['name', 'albums'],\n})\n```\n\n<a name = \"decoupled-complete\"></a>\n\n## The \"Decoupled Job Completion\" pattern\n\nThe _Decoupled Job Completion_ pattern uses a Zeebe Job Worker to activate jobs from the broker, and some other asynchronous (remote) system to do the work.\n\nYou might activate jobs and then send them to a RabbitMQ queue, or to an AWS lambda. In this case, there may be no outcome about the job that this worker can report back to the broker about success or failure. That will be the responsibility of another part of your distributed system.\n\nThe first thing you should do is ensure that you activate the job with sufficient time for the complete execution of your system. Your worker will not be completing the job, but it informs the broker how long the expected loop will take to close.\n\nNext, call `complete.forwarded()` in your job worker handler. This has no side-effect with the broker - so nothing is communicated to Zeebe. The job is still out there with your worker as far as Zeebe is concerned. What this call does is release worker capacity to request more jobs.\n\nIf you are using the Zeebe Node library in the remote system, or if the remote system eventually reports back to you (perhaps over a different RabbitMQ queue), you can use the ZBClient methods `completeJob()`, `failJob()`, and `throwError()` to report the outcome back to the broker.\n\nYou need at least the `job.key`, to be able to correlate the result back to Zeebe. Presumably you also want the information from the remote system about the outcome, and any updated variables.\n\nHere is an example:\n\n-   You have a COBOL system that runs a database.\n-   Somebody wrote an adapter for this COBOL database. In executes commands over SSH.\n-   The adapter is accessible via a RabbitMQ \"request\" queue, which takes a command and a correlation id, so that its response can be correlated to this request.\n-   The adapter sends back the COBOL database system response on a RabbitMQ \"response\" queue, with the correlation id.\n-   It typically takes 15 seconds for the round-trip through RabbitMQ to the COBOL database and back.\n\nYou want to put this system into a Zeebe-orchestrated BPMN model as a task.\n\nRather than injecting a RabbitMQ listener into the job handler, you can \"_fire and forget_\" the request using the decoupled job completion pattern.\n\nHere is how you do it:\n\n-   Your worker gets the job from Zeebe.\n-   Your worker makes the command and sends it down the RabbitMQ \"request\" queue, with the `job.jobKey` as the correlation id.\n-   Your worker calls `complete.forwarded()`\n\nHere is what that looks like in code:\n\n```TypeScript\nimport { RabbitMQSender } from './lib/my-awesome-rabbitmq-api'\nimport { ZBClient, Duration } from 'zeebe-node'\n\nconst zbc = new ZBClient()\n\nconst cobolWorker = zbc.createWorker({\n    taskType: 'cobol-insert',\n    timeout: Duration.seconds.of(20), // allow 5s over the expected 15s\n    taskHandler: (job, complete) => {\n    const { jobKey, variables } = job\n    const request = {\n        correlationId: jobKey,\n        command: `INSERT ${variables.customer} INTO CUSTOMERS`\n    }\n    RabbitMQSender.send({\n        channel: 'COBOL_REQ',\n        request\n    })\n    // Call forwarded() to release worker capacity\n    complete.forwarded()\n})\n```\n\nNow for the response part:\n\n-   Another part of your system listens to the RabbitMQ response queue.\n-   It gets a response back from the COBOL adapter.\n-   It examines the response, then sends the appropriate outcome to Zeebe, using the jobKey that has been attached as the correlationId\n\n```TypeScript\nimport { RabbitMQListener } from './lib/my-awesome-rabbitmq-api'\nimport { ZBClient } from 'zeebe-node'\n\nconst zbc = new ZBClient()\n\nconst RabbitMQListener.listen({\n    channel: 'COBOL_RES',\n    handler: message => {\n        const { outcome, correlationId } = message\n        if (outcome.SUCCESS) {\n            zbc.completeJob({\n                jobKey: correlationId,\n            })\n        }\n        if (outcome.ERROR) {\n            zbc.throwError({\n                jobKey: correlationId,\n                errorCode: \"5\",\n                errorMessage: \"The COBOL Database reported an error. Boo!\"\n            })\n        }\n    })\n}\n```\n\nSee also the section \"[Publish a Message](#publish-message)\", for a pattern that you can use when it is not possible to attach the job key to the round trip data response.\n\n<a name = \"zbbatchworker\"></a>\n\n## The `ZBBatchWorker` Job Worker\n\nThe `ZBBatchWorker` Job Worker batches jobs before calling the job handler. Its fundamental differences from the ZBWorker are:\n\n-   Its job handler receives an _array_ of one or more jobs.\n-   The jobs have `success`, `failure`, `error`, and `forwarded` methods _attached_ to them.\n-   The handler is not invoked immediately, but rather when enough jobs are batched, or a job in the batch is at risk of being timed out by the Zeebe broker.\n\nYou can use the batch worker if you have tasks that _benefit from processing together_, but are _not related in the BPMN model_.\n\nAn example would be a high volume of jobs that require calls to an external system, where you have to pay per call to that system. In that case, you may want to batch up jobs, make one call to the external system, then update all the jobs and send them on their way.\n\nThe batch worker works on a _first-of_ batch size _or_ batch timeout basis.\n\nYou must configure both `jobBatchMinSize` and `jobBatchMaxTime`. Whichever condition is met first will trigger the processing of the jobs:\n\n-   Enough jobs are available to the worker to satisfy the minimum job batch size;\n-   The batch has been building for the maximum amount of time - \"_we're doing this now, before the earliest jobs in the batch time out on the broker_\".\n\nYou should be sure to specify a `timeout` for your worker that is `jobBatchMaxTime` _plus_ the expected latency of the external call _plus_ your processing time and network latency, to avoid the broker timing your batch worker's lock and making the jobs available to another worker. That would defeat the whole purpose.\n\nHere is an example of using the `ZBBatchWorker`:\n\n```TypeScript\nimport { API } from './lib/my-awesome-external-api'\nimport { ZBClient, BatchedJob, Duration } from 'zeebe-node'\n\nconst zbc = new ZBClient()\n\n// Helper function to find a job by its key\nconst findJobByKey = jobs => key => jobs.filter(job => job.jobKey === id)?.[0] ?? []\n\nconst handler = async (jobs: BatchedJob[], worker: ZBBatchWorker) => {\n    worker.log(\"Let's do this!\")\n    const {jobKey, variables} = job\n    // Construct some hypothetical payload with correlation ids and requests\n    const req = jobs.map(job => ({id: jobKey, data: variables.request}))\n    // An uncaught exception will not be managed by the library\n    try {\n        // Our API wrapper turns that into a request, and returns\n        // an array of results with ids\n        const outcomes = await API.post(req)\n        // Construct a find function for these jobs\n        const getJob = findJobByKey(jobs)\n        // Iterate over the results and call the succeed method on the corresponding job,\n        // passing in the correlated outcome of the API call\n        outcomes.forEach(res => getJob(res.id)?.success(res.data))\n    } catch (e) {\n        jobs.forEach(job => job.failure(e.message))\n    }\n}\n\nconst batchWorker = zbc.createBatchWorker({\n    taskType: 'get-data-from-external-api',\n    taskHandler: handler,\n    jobBatchMinSize: 10, // at least 10 at a time\n    jobBatchMaxTime: 60, // or every 60 seconds, whichever comes first\n    timeout: Duration.seconds.of(80) // 80 second timeout means we have 20 seconds to process at least\n})\n```\n\nSee [this blog post](http://joshwulf.com/blog/2020/03/zb-batch-worker/) for some more details on the implementation.\n\n<a name = \"long-polling\"></a>\n\n### Long polling\n\nWith Zeebe 0.21 onward, long polling is supported for clients, and is used by default. Rather than polling continuously for work and getting nothing back, a client can poll once and leave the request open until work appears. This reduces network traffic and CPU utilization in the server. Every JobActivation Request is appended to the event log, so continuous polling can significantly impact broker performance, especially when an exporter is loaded (see [here](https://github.com/creditsenseau/zeebe-client-node-js/issues/64#issuecomment-520233275)).\n\nThe default long polling period is 30s.\n\nTo use a different long polling period, pass in a long poll timeout in milliseconds to the client. All workers created with that client will use it. Alternatively, set a period per-worker.\n\nLong polling for workers is configured in the ZBClient like this:\n\n```typescript\nconst { ZBClient, Duration } = require('zeebe-node')\n\nconst zbc = new ZBClient('serverAddress', {\n\tlongPoll: Duration.minutes.of(10), // Ten minutes - inherited by workers\n})\n\nconst longPollingWorker = zbc.createWorker({\n\ttaskType: 'task-type',\n\ttaskHandler: handler,\n\tlongPoll: Duration.minutes.of(2), // override client, poll 2m\n})\n```\n\n## Client Commands\n\n<a name = \"start-workflow\"></a>\n\n### Start a Workflow Instance\n\n```javascript\nconst ZB = require('zeebe-node')\n\n;(async () => {\n\tconst zbc = new ZB.ZBClient('localhost:26500')\n\tconst result = await zbc.createWorkflowInstance('test-process', {\n\t\ttestData: 'something',\n\t})\n\tconsole.log(result)\n})()\n```\n\nExample output:\n\n```javascript\n\n{ workflowKey: '3',\n  bpmnProcessId: 'test-process',\n  version: 1,\n  workflowInstanceKey: '569' }\n\n```\n\n<a name = \"start-specific-version\"></a>\n\n### Start a Workflow Instance of a specific version of a Workflow definition\n\nFrom version 0.22 of the client onward:\n\n```javascript\nconst ZB = require('zeebe-node')\n\n;(async () => {\n\tconst zbc = new ZB.ZBClient('localhost:26500')\n\tconst result = await zbc.createWorkflowInstance({\n\t\tbpmnProcessId: 'test-process',\n\t\tvariables: {\n\t\t\ttestData: 'something',\n\t\t},\n\t\tversion: 5,\n\t})\n\tconsole.log(result)\n})()\n```\n\n<a name = \"start-await\"></a>\n\n### Start a Workflow Instance and await the Workflow Outcome\n\nFrom version 0.22 of the broker and client, you can await the outcome of a workflow end-to-end execution:\n\n```typescript\nasync function getOutcome() {\n\tconst result = await zbc.createWorkflowInstanceWithResult(processId, {\n\t\tsourceValue: 5,\n\t})\n\treturn result\n}\n```\n\nBe aware that by default, **this will throw an exception if the workflow takes longer than 15 seconds to complete**.\n\nTo override the gateway's default timeout for a workflow that needs more time to complete:\n\n```typescript\nconst { ZBClient, Duration } = require('zeebe-node')\n\nconst zbc = new ZBClient()\n\nconst result = await zbc.createWorkflowInstanceWithResult({\n\tbpmnProcessId: processId,\n\tvariables: {\n\t\tsourceValue: 5,\n\t\totherValue: 'rome',\n\t},\n\trequestTimeout: Duration.seconds.of(25),\n\t// also works supplying a number of milliseconds\n\t// requestTimeout: 25000\n})\n```\n\n<a name = \"publish-message\"></a>\n\n### Publish a Message\n\nYou can publish a message to the Zeebe broker that will be correlated with a running workflow instance:\n\n```javascript\nconst { ZBClient, Duration } = require('zeebe-node')\n\nconst zbc = new ZBClient()\n\nzbc.publishMessage({\n\tcorrelationKey: 'value-to-correlate-with-workflow-variable',\n\tmessageId: uuid.v4(),\n\tname: 'message-name',\n\tvariables: { valueToAddToWorkflowVariables: 'here', status: 'PROCESSED' },\n\ttimeToLive: Duration.seconds.of(10), // seconds\n})\n```\n\nWhen would you do this? Well, the sky is not even the limit when it comes to thinking creatively about building a system with Zeebe - _and_ here's one concrete example to get you thinking:\n\nRecall the example of the _remote COBOL database_ in the section \"[The \"Decoupled Job Completion\" pattern](#decoupled-complete)\". We're writing code to allow that system to be participate in a BPMN-modelling workflow orchestrated by Zeebe.\n\nBut what happens if the adapter for that system has been written in such a way that there is no opportunity to attach metadata to it? In that case we have no opportunity to attach a job key. Maybe you send the fixed data for the command, and you have to correlate the response based on those fields.\n\nAnother example: think of a system that emits events, and has no knowledge of a running workflow. An example from one system that I orchestrate with Zeebe is Minecraft. A logged-in user in the game performs some action, and code in the game emits an event. I can catch that event in my Node-based application, but I have no knowledge of which running workflow to target - _and_ the event was not generated from a BPMN task providing a worker with the complete context of a workflow.\n\nIn these two cases, I can publish a message to Zeebe, and let the broker figure out which workflows are:\n\n-   Sitting at an intermediate message catch event waiting for this message; or\n-   In a sub-process that has a boundary event that will be triggered by this message; or\n-   Would be started by a message start event, on receiving this message.\n\nThe Zeebe broker correlates a message to a running workflow instance _not on the job key_ - but on _the value of one of the workflow variables_ (for intermediate message events) and _the message name_ (for all message events, including start messages).\n\nSo the response from your COBOL database system, sans job key, is sent back to Zeebe from the RabbitMQListener not via `completeJob()`, but with `publishMessage()`, and the value of the payload is used to figure out which workflow it is for.\n\nIn the case of the Minecraft event, a message is published to Zeebe with the Minecraft username, and that is used by Zeebe to determine which workflows are running for that user and are interested in that event.\n\nSee the article \"[Zeebe Message Correlation](https://zeebe.io/blog/2019/08/zeebe-message-correlation/)\" for a complete example with code.\n\n<a name=\"publish-start-message\"></a>\n\n### Publish a Start Message\n\nYou can also publish a message targeting a [Message Start Event](https://github.com/zeebe-io/zeebe/issues/1858).\nIn this case, the correlation key is optional, and all Message Start events that match the `name` property will receive the message.\n\nYou can use the `publishStartMessage()` method to publish a message with no correlation key (it will be set to a random uuid in the background):\n\n```javascript\nconst { ZBClient, Duration } = require('zeebe-node')\n\nconst zbc = new ZB.ZBClient('localhost:26500')\nzbc.publishStartMessage({\n\tmessageId: uuid.v4(),\n\tname: 'message-name',\n\tvariables: { initialWorkflowVariable: 'here' },\n\ttimeToLive: Duration.seconds.of(10), // seconds\n})\n```\n\nBoth normal messages and start messages can be published idempotently by setting both the `messageId` and the `correlationKey`. They will only ever be correlated once. See: [A message can be published idempotent](https://github.com/zeebe-io/zeebe/issues/1012).\n\n<a name=\"activate-jobs\"></a>\n\n### Activate Jobs\n\nIf you have some use case that doesn't fit the existing workers, you can write your own custom workers using the `ZBClient.activateJobs()` method. It takes an `ActivateJobsRequest` object, and returns a stream for that call.\n\nAttach a listener to the stream's 'data' event, and it will be called with an `ActivateJobsResponse` object if there are jobs to work on.\n\nTo complete these jobs, use the `ZBClient` methods `completeJob()`, `failJob()`, and `throwError()`.\n\nFor more details, read the source code of the library, particularly the `ZBWorkerBase` class. This is an advanced use case, and the existing code in the library is the best documentation.\n\n## Other Concerns\n\n<a name = \"graceful-shutdown\"></a>\n\n### Graceful Shutdown\n\nTo drain workers, call the `close()` method of the ZBClient. This causes all workers using that client to stop polling for jobs, and returns a Promise that resolves when all active jobs have either finished or timed out.\n\n```javascript\nconsole.log('Closing client...')\nzbc.close().then(() => console.log('All workers closed'))\n```\n\n<a name = \"logging\"></a>\n\n## Logging\n\nControl the log output for the client library by setting the ZBClient log level. Valid log levels are `NONE` (supress all logging), `ERROR` (log only exceptions), `INFO` (general logging), or `DEBUG` (verbose logging). You can set this in the client constructor:\n\n```typescript\nconst zbc = new ZBClient('localhost', { loglevel: 'DEBUG' })\n```\n\nAnd also via the environment:\n\n```bash\nZEEBE_NODE_LOG_LEVEL='ERROR' node start.js\n```\n\nBy default the library uses `console.info` and `console.error` for logging. You can also pass in a custom logger, such as [pino](https://github.com/pinojs/pino):\n\n```typescript\nconst logger = require('pino')()\nconst zbc = new ZBClient({ stdout: logger })\n```\n\nFrom version v0.23.0-alpha.1, the library logs human-readable logs by default, using the `ZBSimpleLogger`. If you want structured logs as stringified JSON, pass in `ZBJSONLogger` to the constructor `stdout` option, like this:\n\n```typescript\nconst { ZBJsonLogger, ZBClient } = require('zeebe-node')\nconst zbc = new ZBClient({ stdout: ZBJsonLogger })\n```\n\nYou can also control this via environment variables:\n\n```bash\nexport ZEEBE_NODE_LOG_TYPE=SIMPLE  # Simple Logger (default)\nexport ZEEBE_NODE_LOG_TYPE=JSON  # JSON Logger\n```\n\n<a name = \"generate-constants\"></a>\n\n### Generating TypeScript constants for BPMN Models\n\nMessage names and Task Types are untyped magic strings. You can generate type information to avoid some classes of errors.\n\n#### 0.22.0-alpha.5 and above\n\nInstall the package globally:\n\n```\nnpm i -g zeebe-node\n```\n\nNow you have the command `zeebe-node <filename>` that parses a BPMN file and emits type definitions.\n\n#### All versions\n\nThe `BpmnParser` class provides a static method `generateConstantsForBpmnFiles()`.\nThis method takes a filepath and returns TypeScript definitions that you can use to avoid typos in your code, and to reason about the completeness of your task worker coverage.\n\n```javascript\nconst ZB = require('zeebe-node')\n;(async () => {\n\tconsole.log(await ZB.BpmnParser.generateConstantsForBpmnFiles(workflowFile))\n})()\n```\n\nThis will produce output similar to:\n\n```typescript\n// Autogenerated constants for msg-start.bpmn\n\nexport enum TaskType = {\n    CONSOLE_LOG = \"console-log\"\n};\n\nexport enum MessageName = {\n    MSG_EMIT_FRAME = \"MSG-EMIT_FRAME\",\n    MSG_START_JOB = \"MSG-START_JOB\"\n};\n```\n\n<a name = \"generate-code\"></a>\n\n## Generating code from a BPM Model file\n\nYou can scaffold your worker code from a BPMN file with the `zeebe-node` command. To use this command, install the package globally with:\n\n```bash\nnpm i -g zeebe-node\n```\n\nPass in the path to the BPMN file, and it will output a file to implement it:\n\n```bash\nzeebe-node my-model.bpmn\n```\n\n<a name = \"strongly-typed\"></a>\n\n### Writing Strongly-typed Job Workers\n\nYou can provide interfaces to get design-time type safety and intellisense on the workflow variables passed in the a worker job handler, the custom headers that it will receive, and the variables that it will pass back to Zeebe in the `complete.success` call:\n\n```TypeScript\ninterface InputVariables {\n    name: string,\n    age: number,\n    preferences: {\n        beverage: 'Coffee' | 'Tea' | 'Beer' | 'Water',\n        color: string\n    }\n}\n\ninterface OutputVariables {\n    suggestedGift: string\n}\n\ninterface CustomHeaders {\n    occasion: 'Birthday' | 'Christmas' | 'Hannukah' | 'Diwali'\n}\n\nconst giftSuggester = zbc.createWorker<\n    InputVariables,\n    CustomHeaders,\n    OutputVariables>\n    ('get-gift-suggestion', (job, complete) => {\n        const suggestedGift = `${job.customHeaders.occasion} ${job.variables.preferences.beverage}`\n        complete.success({ suggestedGift })\n})\n```\n\nIf you decouple the declaration of the job handler from the `createWorker` call, you will need to explicitly specify its type, like this:\n\n```TypeScript\nimport { ZBWorkerTaskHandler } from 'zeebe-node'\n\nfunction getGiftSuggestion(job, complete): ZBWorkerTaskHandler<InputVariables, CustomHeaders, OutputVariables> {\n    const suggestedGift = `${job.customHeaders.occasion} ${job.variables.preferences.beverage}`\n    complete.success({ suggestedGift })\n}\n\nconst giftSuggester = zbc.createWorker('get-gift-suggestion', getGiftSuggestion)\n\n```\n\n<a name = \"run-time-safety\"></a>\n\n## Run-time Type Safety\n\nThe parameterization of the client and workers helps to catch errors in code, and if your interface definitions are good, can go a long way to making sure that your workers and client emit the correct payloads and have a strong expectation about what they will receive, but it does not give you any _run-time safety_.\n\nYour type definition may be incorrect, or the variables or custom headers may simply not be there at run-time, as there is no type checking in the broker, and other factors are involved, such as tasks with input and output mappings, and data added to the workflow variables by REST calls and other workers.\n\nYou should consider:\n\n-   Writing interface definitions for your payloads to get design-time assist for protection against spelling errors as you demarshal and update variables.\n-   Testing for the existence of variables and properties on payloads, and writing defensive pathways to deal with missing properties. If you mark _everything_ as optional in your interfaces, the type-checker will force you to write that code.\n-   Surfacing code exceptions operationally to detect and diagnose mismatched expectations.\n-   If you want to validate inputs and outputs to your system at runtime, you can use [io-ts](https://github.com/gcanti/io-ts). Once data goes into that, it either exits through an exception handler, or is guaranteed to have the shape of the defined codec at run-time.\n\nAs with everything, it is a balancing act / trade-off between correctness, safety, and speed. You do not want to lock everything down while you are still exploring.\n\nI recommend the following scale, to match the maturity of your system:\n\n-   Start with `<any>` typing for the workers; then\n-   Develop interfaces to describe the DTOs represented in your workflow variables;\n-   Use optional types on those interfaces to check your defensive programming structures;\n-   Lock down the run-time behaviour with io-ts as the boundary validator.\n\nYou may choose to start with the DTOs. Anyway, there are options.\n\n<a name = \"developing\"></a>\n\n## Developing Zeebe Node\n\nThe source is written in TypeScript in `src`, and compiled to ES6 in the `dist` directory.\n\nTo build:\n\n```bash\nnpm run build\n```\n\nTo start a watcher to build the source and API docs while you are developing:\n\n```bash\nnpm run dev\n```\n\n<a name = \"tests\"></a>\n\n### Tests\n\nTests are written in Jest, and live in the `src/__tests__` directory. To run the unit tests:\n\n```bash\nnpm t\n```\n\nIntegration tests are in the `src/__tests__/integration` directory.\n\nThey require a Zeebe broker to run. You can run them using the [Circle CI CLI](https://circleci.com/docs/2.0/local-cli/):\n\n```bash\ncircleci local execute -c .circleci/config.yml --job test\n```\n\nOr you can start a dockerised broker:\n\n```bash\ncd docker\ndocker-compose up\n```\n\nAnd then run them manually:\n\n```bash\nnpm run test:integration\n```\n\nFor the failure test, you need to run Operate ([docker-compose config](https://github.com/zeebe-io/zeebe-docker-compose/blob/master/operate/docker-compose.yml)) and manually verify that an incident has been raised at [http://localhost:8080](http://localhost:8080).\n\n<a name = \"writing-tests\"></a>\n\n### Writing Tests\n\nZeebe is inherently stateful, so integration tests need to be carefully isolated so that workers from one test do not service tasks in another test. Jest runs tests in a random order, so intermittent failures are the outcome of tests that mutate shared state.\n\nThe tests use a templating function to replace the process id, task types and message names in the bpmn model to produce distinct, isolated namespaces for each test and each test run.\n\n<a name = \"contributors\"></a>\n\n## Contributors\n\n| Name                                                         |\n| ------------------------------------------------------------ |\n| **[Josh Wulf](https://github.com/jwulf)**                    |\n| **[Colin Raddatz](https://github.com/ColRad)**               |\n| **[Jarred Filmer](https://github.com/BrighTide)**            |\n| **[Timothy Colbert](https://github.com/s3than)**             |\n| **[Olivier Albertini](https://github.com/OlivierAlbertini)** |\n| **[Patrick Dehn](https://github.com/pedesen)**               |\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/creditsenseau/zeebe-client-node-js.git"
  },
  "scripts": {
    "build": "tsc --build src/tsconfig.json",
    "debug": "NODE_DEBUG=http2 GRPC_TRACE=channel,call_stream GRPC_VERBOSITY=DEBUG ../node/out/Debug/node --inspect-brk node_modules/.bin/jest Worker-Failure",
    "dev": "tsc-watch --onSuccess \"npm run test&docs\" -p tsconfig.json --outDir dist",
    "docs": "typedoc --out ./docs --tsconfig ./tsconfig.json --excludePrivate --mode file --sourcefile-url-prefix \"https://github.com/creditsenseau/\"",
    "prepare": "tsc --build src/tsconfig.json",
    "test": "jest --runInBand --detectOpenHandles --testPathIgnorePatterns integration local-integration disconnection",
    "test&docs": "npm test && npm run docs",
    "test:disconnect": "jest --runInBand --verbose true --detectOpenHandles disconnection",
    "test:integration": "jest --runInBand --testPathIgnorePatterns disconnection --detectOpenHandles --verbose true",
    "test:local": "jest --runInBand --verbose true --detectOpenHandles local-integration",
    "watch": "tsc --build src/tsconfig.json -w"
  },
  "version": "0.23.3"
}
